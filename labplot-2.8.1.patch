diff --git a/ChangeLog b/ChangeLog
index 9b501c1c2..c3cc61cf9 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,13 @@
+-----2.9.0 -----
+-----2.8.2 -----
+Bug fixes:
+	* [CAS] Fixed the regression introduced after the python2 backend was deprecated in Cantor
+	* [Axis label] Fix "power of" notations for negative values, show "0" for zero
+		and improve auto precision for small values
+	* BUG 427190 - Fixed resetting parser error count on some platforms (Debian, Manjaro)
+	* BUG 429110 - Support semicolon as function argument separator for locale with comma as decimal separator
+	* BUG 429368 - Fix validation of custom model equation in fit dock
+	* BUG 431535 - Save/Load value format
 -----2.8.1 -----
 	* [worksheet] allow to change the background color for axis labels (default: transparent)
 	* [worksheet] allow to copy the plot cursor cordinates
diff --git a/org.kde.labplot2.appdata.xml b/org.kde.labplot2.appdata.xml
index 9a5f6a29b..039639cff 100644
--- a/org.kde.labplot2.appdata.xml
+++ b/org.kde.labplot2.appdata.xml
@@ -201,4 +201,12 @@
   <provides>
     <binary>labplot2</binary>
   </provides>
+  <content_rating type="oars-1.1" />
+  <releases>
+    <release version="2.8.1" date="2020-11-13"/>
+    <release version="2.8.0" date="2020-09-16"/>
+  </releases>
+  <custom>
+    <value key="KDE::windows_store">https://www.microsoft.com/store/apps/9ngxfc68925l</value>
+  </custom>
 </component>
diff --git a/src/backend/cantorWorksheet/VariableParser.cpp b/src/backend/cantorWorksheet/VariableParser.cpp
index a3c9a2db9..1f240ce62 100644
--- a/src/backend/cantorWorksheet/VariableParser.cpp
+++ b/src/backend/cantorWorksheet/VariableParser.cpp
@@ -38,9 +38,9 @@ VariableParser::VariableParser(QString name, QString value)
 	PERFTRACE("parsing variable");
 	if (m_backendName.compare(QStringLiteral("Maxima"), Qt::CaseInsensitive) == 0)
 		parseMaximaValues();
-	else if (m_backendName.compare(QStringLiteral("Python 3"), Qt::CaseInsensitive) == 0)
-		parsePythonValues();
-	else if (m_backendName.compare(QStringLiteral("Python 2"), Qt::CaseInsensitive) == 0)
+	else if ( (m_backendName.compare(QStringLiteral("Python"), Qt::CaseInsensitive) == 0)
+			|| (m_backendName.compare(QStringLiteral("Python 3"), Qt::CaseInsensitive) == 0)
+			|| (m_backendName.compare(QStringLiteral("Python 2"), Qt::CaseInsensitive) == 0) )
 		parsePythonValues();
 	else if (m_backendName.compare(QStringLiteral("Sage"), Qt::CaseInsensitive) == 0)
 		parsePythonValues();
diff --git a/src/backend/gsl/parser.y b/src/backend/gsl/parser.y
index 033d814a3..1b720f014 100644
--- a/src/backend/gsl/parser.y
+++ b/src/backend/gsl/parser.y
@@ -102,6 +102,9 @@ expr:      NUM       { $$ = $1;                            }
 | FNCT '(' expr ',' expr ')'  { $$ = (*((func_t2)($1->value.fnctptr)))($3,$5); }
 | FNCT '(' expr ',' expr ','expr ')'  { $$ = (*((func_t3)($1->value.fnctptr)))($3,$5,$7); }
 | FNCT '(' expr ',' expr ',' expr ','expr ')'  { $$ = (*((func_t4)($1->value.fnctptr)))($3,$5,$7,$9); }
+| FNCT '(' expr ';' expr ')'  { $$ = (*((func_t2)($1->value.fnctptr)))($3,$5); }
+| FNCT '(' expr ';' expr ';'expr ')'  { $$ = (*((func_t3)($1->value.fnctptr)))($3,$5,$7); }
+| FNCT '(' expr ';' expr ';' expr ';'expr ')'  { $$ = (*((func_t4)($1->value.fnctptr)))($3,$5,$7,$9); }
 | expr '+' expr      { $$ = $1 + $3;                       }
 | expr '-' expr      { $$ = $1 - $3;                       }
 | expr '*' expr      { $$ = $1 * $3;                       }
@@ -298,6 +301,7 @@ double parse(const char* string, const char* locale) {
 
 	/* parameter for yylex */
 	res = NAN;	/* default value */
+	yynerrs = 0;	/* reset error count */
 	yyparse(&p);
 
 	pdebug("PARSER: parse() DONE (result = %g, errors = %d)\n*******************************\n", res, parse_errors());
diff --git a/src/backend/worksheet/plots/cartesian/Axis.cpp b/src/backend/worksheet/plots/cartesian/Axis.cpp
index 7dacc7e9f..b61b63fbe 100644
--- a/src/backend/worksheet/plots/cartesian/Axis.cpp
+++ b/src/backend/worksheet/plots/cartesian/Axis.cpp
@@ -1445,13 +1445,13 @@ void AxisPrivate::retransformTickLabelStrings() {
 
 	if (labelsAutoPrecision) {
 		//check, whether we need to increase the current precision
-		int newPrecision = upperLabelsPrecision(labelsPrecision);
+		int newPrecision = upperLabelsPrecision(labelsPrecision, labelsFormat);
 		if (newPrecision != labelsPrecision) {
 			labelsPrecision = newPrecision;
 			emit q->labelsPrecisionChanged(labelsPrecision);
 		} else {
 			//check, whether we can reduce the current precision
-			newPrecision = lowerLabelsPrecision(labelsPrecision);
+			newPrecision = lowerLabelsPrecision(labelsPrecision, labelsFormat);
 			if (newPrecision != labelsPrecision) {
 				labelsPrecision = newPrecision;
 				emit q->labelsPrecisionChanged(labelsPrecision);
@@ -1504,32 +1504,56 @@ void AxisPrivate::retransformTickLabelStrings() {
 		} else if (labelsFormat == Axis::LabelsFormat::ScientificE) {
 			QString nullStr = numberLocale.toString(0., 'e', labelsPrecision);
 			for (const auto value : tickLabelValues) {
-				str = numberLocale.toString(value, 'e', labelsPrecision);
+				if (value == 0)	// just show "0"
+					str = numberLocale.toString(value, 'f', 0);
+				else
+					str = numberLocale.toString(value, 'e', labelsPrecision);
 				if (str == "-" + nullStr) str = nullStr;
 				str = labelsPrefix + str + labelsSuffix;
 				tickLabelStrings << str;
 			}
 		} else if (labelsFormat == Axis::LabelsFormat::Powers10) {
 			for (const auto value : tickLabelValues) {
-				str = "10<sup>" + numberLocale.toString(log10(value), 'f', labelsPrecision) + "</sup>";
+				if (value == 0)	// just show "0"
+					str = numberLocale.toString(value, 'f', 0);
+				else {
+					str = "10<sup>" + numberLocale.toString(log10(qAbs(value)), 'f', labelsPrecision) + "</sup>";
+					if (value < 0)
+						str.prepend("-");
+				}
 				str = labelsPrefix + str + labelsSuffix;
 				tickLabelStrings << str;
 			}
 		} else if (labelsFormat == Axis::LabelsFormat::Powers2) {
 			for (const auto value : tickLabelValues) {
-				str = "2<span style=\"vertical-align:super\">" + numberLocale.toString(log2(value), 'f', labelsPrecision) + "</span>";
+				if (value == 0)	// just show "0"
+					str = numberLocale.toString(value, 'f', 0);
+				else  {
+					str = "2<span style=\"vertical-align:super\">" + numberLocale.toString(log2(qAbs(value)), 'f', labelsPrecision) + "</span>";
+					if (value < 0)
+						str.prepend("-");
+				}
 				str = labelsPrefix + str + labelsSuffix;
 				tickLabelStrings << str;
 			}
 		} else if (labelsFormat == Axis::LabelsFormat::PowersE) {
 			for (const auto value : tickLabelValues) {
-				str = "e<span style=\"vertical-align:super\">" + numberLocale.toString(log(value), 'f', labelsPrecision) + "</span>";
+				if (value == 0)	// just show "0"
+					str = numberLocale.toString(value, 'f', 0);
+				else {
+					str = "e<span style=\"vertical-align:super\">" + numberLocale.toString(log(qAbs(value)), 'f', labelsPrecision) + "</span>";
+					if (value < 0)
+						str.prepend("-");
+				}
 				str = labelsPrefix + str + labelsSuffix;
 				tickLabelStrings << str;
 			}
 		} else if (labelsFormat == Axis::LabelsFormat::MultipliesPi) {
 			for (const auto value : tickLabelValues) {
-				str = "<span>" + numberLocale.toString(value / M_PI, 'f', labelsPrecision) + "</span>" + QChar(0x03C0);
+				if (value == 0)	// just show "0"
+					str = numberLocale.toString(value, 'f', 0);
+				else
+					str = "<span>" + numberLocale.toString(value / M_PI, 'f', labelsPrecision) + "</span>" + QChar(0x03C0);
 				str = labelsPrefix + str + labelsSuffix;
 				tickLabelStrings << str;
 			}
@@ -1552,8 +1576,8 @@ void AxisPrivate::retransformTickLabelStrings() {
 	returns the smallest upper limit for the precision
 	where no duplicates for the tick label float occur.
  */
-int AxisPrivate::upperLabelsPrecision(int precision) {
-	DEBUG(Q_FUNC_INFO << ", precision =" << precision);
+int AxisPrivate::upperLabelsPrecision(const int precision, const Axis::LabelsFormat format) {
+	DEBUG(Q_FUNC_INFO << ", precision = " << precision);
 
 	// avoid problems with zero range axis
 	if (tickLabelValues.isEmpty() || qFuzzyCompare(tickLabelValues.constFirst(), tickLabelValues.constLast())) {
@@ -1565,8 +1589,28 @@ int AxisPrivate::upperLabelsPrecision(int precision) {
 	//round float to the current precision and look for duplicates.
 	//if there are duplicates, increase the precision.
 	QVector<double> tempValues;
-	for (const auto value : tickLabelValues)
-		tempValues.append( nsl_math_round_places(value, precision) );
+	switch (format) {
+	case Axis::LabelsFormat::Decimal:
+	case Axis::LabelsFormat::MultipliesPi:
+		for (const auto value : tickLabelValues)
+			tempValues.append( nsl_math_round_places(value, precision) );
+		break;
+	case Axis::LabelsFormat::ScientificE:
+		for (const auto value : tickLabelValues)
+			tempValues.append( nsl_math_round_precision(value, precision) );
+		break;
+	case Axis::LabelsFormat::Powers10:
+		for (const auto value : tickLabelValues)
+			tempValues.append( nsl_math_round_places(log10(qAbs(value)), precision) );
+		break;
+	case Axis::LabelsFormat::Powers2:
+		for (const auto value : tickLabelValues)
+			tempValues.append( nsl_math_round_places(log2(qAbs(value)), precision) );
+		break;
+	case Axis::LabelsFormat::PowersE:
+		for (const auto value : tickLabelValues)
+			tempValues.append( nsl_math_round_places(log(qAbs(value)), precision) );
+	}
 
 	for (int i = 0; i < tempValues.size(); ++i) {
 		for (int j = 0; j < tempValues.size(); ++j) {
@@ -1575,7 +1619,7 @@ int AxisPrivate::upperLabelsPrecision(int precision) {
 
 			//duplicate for the current precision found, increase the precision and check again
 			if (tempValues.at(i) == tempValues.at(j))
-				return upperLabelsPrecision(precision + 1);
+				return upperLabelsPrecision(precision + 1, format);
 		}
 	}
 
@@ -1588,13 +1632,34 @@ int AxisPrivate::upperLabelsPrecision(int precision) {
 	returns highest lower limit for the precision
 	where no duplicates for the tick label float occur.
 */
-int AxisPrivate::lowerLabelsPrecision(int precision) {
-// 	DEBUG("AxisPrivate::lowerLabelsPrecision() precision =" << precision);
-	//round float to the current precision and look for duplicates.
+int AxisPrivate::lowerLabelsPrecision(const int precision, const Axis::LabelsFormat format) {
+	DEBUG(Q_FUNC_INFO << ", precision = " << precision);
+	//round value to the current precision and look for duplicates.
 	//if there are duplicates, decrease the precision.
 	QVector<double> tempValues;
-	for (auto value : tickLabelValues)
-		tempValues.append( nsl_math_round_places(value, precision-1) );
+	switch (format) {
+	case Axis::LabelsFormat::Decimal:
+	case Axis::LabelsFormat::MultipliesPi:
+		for (auto value : tickLabelValues)
+			tempValues.append( nsl_math_round_places(value, precision-1) );
+		break;
+	case Axis::LabelsFormat::ScientificE:
+		for (auto value : tickLabelValues)
+			tempValues.append( nsl_math_round_precision(value, precision-1) );
+		break;
+	case Axis::LabelsFormat::Powers10:
+		for (auto value : tickLabelValues)
+			tempValues.append( nsl_math_round_places(log10(qAbs(value)), precision-1) );
+		break;
+	case Axis::LabelsFormat::Powers2:
+		for (auto value : tickLabelValues)
+			tempValues.append( nsl_math_round_places(log2(qAbs(value)), precision-1) );
+		break;
+	case Axis::LabelsFormat::PowersE:
+		for (auto value : tickLabelValues)
+			tempValues.append( nsl_math_round_places(log(qAbs(value)), precision-1) );
+	}
+
 
 	//check whether we have duplicates with reduced precision
 	//-> current precision cannot be reduced, return the current value
@@ -1622,7 +1687,7 @@ int AxisPrivate::lowerLabelsPrecision(int precision) {
 			return 0;
 	} else {
 		//no duplicates found, reduce further, and check again
-		return lowerLabelsPrecision(precision - 1);
+		return lowerLabelsPrecision(precision - 1, format);
 	}
 }
 
diff --git a/src/backend/worksheet/plots/cartesian/AxisPrivate.h b/src/backend/worksheet/plots/cartesian/AxisPrivate.h
index 67500ec65..02898068c 100644
--- a/src/backend/worksheet/plots/cartesian/AxisPrivate.h
+++ b/src/backend/worksheet/plots/cartesian/AxisPrivate.h
@@ -155,8 +155,8 @@ private:
 	void paint(QPainter*, const QStyleOptionGraphicsItem*, QWidget* widget = nullptr) override;
 
 	void addArrow(QPointF point, int direction);
-	int upperLabelsPrecision(int);
-	int lowerLabelsPrecision(int);
+	int upperLabelsPrecision(int precision, Axis::LabelsFormat);
+	int lowerLabelsPrecision(int precision, Axis::LabelsFormat);
 	bool transformAnchor(QPointF*);
 
 	QPainterPath arrowPath;
diff --git a/src/backend/worksheet/plots/cartesian/CartesianPlot.cpp b/src/backend/worksheet/plots/cartesian/CartesianPlot.cpp
index df0bfea71..0bb2c01d0 100644
--- a/src/backend/worksheet/plots/cartesian/CartesianPlot.cpp
+++ b/src/backend/worksheet/plots/cartesian/CartesianPlot.cpp
@@ -1723,7 +1723,7 @@ void CartesianPlot::yDataChanged() {
 		auto* curve = dynamic_cast<XYCurve*>(QObject::sender());
 		if (curve) {
 			const AbstractColumn* col = curve->yColumn();
-			if (col->columnMode() == AbstractColumn::ColumnMode::DateTime && d->xRangeFormat != RangeFormat::DateTime) {
+			if (col->columnMode() == AbstractColumn::ColumnMode::DateTime && d->yRangeFormat != RangeFormat::DateTime) {
 				setUndoAware(false);
 				setYRangeFormat(RangeFormat::DateTime);
 				setUndoAware(true);
diff --git a/src/backend/worksheet/plots/cartesian/XYCurve.cpp b/src/backend/worksheet/plots/cartesian/XYCurve.cpp
index 1df93ac36..fdf31b1af 100644
--- a/src/backend/worksheet/plots/cartesian/XYCurve.cpp
+++ b/src/backend/worksheet/plots/cartesian/XYCurve.cpp
@@ -3036,7 +3036,9 @@ void XYCurve::save(QXmlStreamWriter* writer) const {
 	writer->writeAttribute( "distance", QString::number(d->valuesDistance) );
 	writer->writeAttribute( "rotation", QString::number(d->valuesRotationAngle) );
 	writer->writeAttribute( "opacity", QString::number(d->valuesOpacity) );
-	//TODO values format and precision
+	writer->writeAttribute("numericFormat", QString(d->valuesNumericFormat));
+	writer->writeAttribute("dateTimeFormat", d->valuesDateTimeFormat);
+	writer->writeAttribute( "precision", QString::number(d->valuesPrecision) );
 	writer->writeAttribute( "prefix", d->valuesPrefix );
 	writer->writeAttribute( "suffix", d->valuesSuffix );
 	WRITE_QCOLOR(d->valuesColor);
@@ -3145,6 +3147,15 @@ bool XYCurve::load(XmlStreamReader* reader, bool preview) {
 			READ_DOUBLE_VALUE("rotation", valuesRotationAngle);
 			READ_DOUBLE_VALUE("opacity", valuesOpacity);
 
+			str = attribs.value("numericFormat").toString();
+			if (str.isEmpty())
+				reader->raiseWarning(attributeWarning.subs("numericFormat").toString());
+			else
+				d->valuesNumericFormat = *(str.toLatin1().data());
+
+			READ_STRING_VALUE("dateTimeFormat", valuesDateTimeFormat);
+			READ_INT_VALUE("precision", valuesPrecision, int);
+
 			//don't produce any warning if no prefix or suffix is set (empty string is allowed here in xml)
 			d->valuesPrefix = attribs.value("prefix").toString();
 			d->valuesSuffix = attribs.value("suffix").toString();
diff --git a/src/kdefrontend/dockwidgets/XYCurveDock.cpp b/src/kdefrontend/dockwidgets/XYCurveDock.cpp
index 566fcb429..be455512f 100644
--- a/src/kdefrontend/dockwidgets/XYCurveDock.cpp
+++ b/src/kdefrontend/dockwidgets/XYCurveDock.cpp
@@ -155,8 +155,8 @@ XYCurveDock::XYCurveDock(QWidget* parent) : BaseDock(parent) {
 	connect(ui.cbValuesNumericFormat, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &XYCurveDock::valuesNumericFormatChanged);
 	connect(ui.sbValuesPrecision, QOverload<int>::of(&QSpinBox::valueChanged), this, &XYCurveDock::valuesPrecisionChanged);
 	connect(ui.cbValuesDateTimeFormat, &QComboBox::currentTextChanged, this, &XYCurveDock::valuesDateTimeFormatChanged);
-	connect( ui.leValuesPrefix, SIGNAL(returnPressed()), this, SLOT(valuesPrefixChanged()) );
-	connect( ui.leValuesSuffix, SIGNAL(returnPressed()), this, SLOT(valuesSuffixChanged()) );
+	connect(ui.leValuesPrefix, &QLineEdit::textChanged, this, &XYCurveDock::valuesPrefixChanged);
+	connect(ui.leValuesSuffix, &QLineEdit::textChanged, this, &XYCurveDock::valuesSuffixChanged);
 	connect( ui.kfrValuesFont, SIGNAL(fontSelected(QFont)), this, SLOT(valuesFontChanged(QFont)) );
 	connect( ui.kcbValuesColor, SIGNAL(changed(QColor)), this, SLOT(valuesColorChanged(QColor)) );
 
@@ -167,7 +167,7 @@ XYCurveDock::XYCurveDock(QWidget* parent) : BaseDock(parent) {
 	connect( ui.cbFillingImageStyle, SIGNAL(currentIndexChanged(int)), this, SLOT(fillingImageStyleChanged(int)) );
 	connect( ui.cbFillingBrushStyle, SIGNAL(currentIndexChanged(int)), this, SLOT(fillingBrushStyleChanged(int)) );
 	connect(ui.bFillingOpen, SIGNAL(clicked(bool)), this, SLOT(selectFile()));
-	connect( ui.leFillingFileName, SIGNAL(returnPressed()), this, SLOT(fileNameChanged()) );
+	connect(ui.leFillingFileName, &QLineEdit::textChanged, this, &XYCurveDock::fileNameChanged);
 	connect( ui.leFillingFileName, SIGNAL(textChanged(QString)), this, SLOT(fileNameChanged()) );
 	connect( ui.kcbFillingFirstColor, SIGNAL(changed(QColor)), this, SLOT(fillingFirstColorChanged(QColor)) );
 	connect( ui.kcbFillingSecondColor, SIGNAL(changed(QColor)), this, SLOT(fillingSecondColorChanged(QColor)) );
diff --git a/src/kdefrontend/dockwidgets/XYFitCurveDock.cpp b/src/kdefrontend/dockwidgets/XYFitCurveDock.cpp
index 3c28f9e4c..625d35fc4 100644
--- a/src/kdefrontend/dockwidgets/XYFitCurveDock.cpp
+++ b/src/kdefrontend/dockwidgets/XYFitCurveDock.cpp
@@ -923,7 +923,7 @@ void XYFitCurveDock::updateParameterList() {
 
 	ExpressionParser* parser = ExpressionParser::getInstance();
 	QStringList vars; // variables that are known
-	vars << "x";	//TODO: others?
+	vars << "x";	//TODO: generalize when we support other XYEquationCurve::EquationType
 	m_fitData.paramNames = m_fitData.paramNamesUtf8 = parser->getParameter(m_fitData.model, vars);
 
 	// if number of parameter changed
@@ -955,8 +955,10 @@ void XYFitCurveDock::updateParameterList() {
 void XYFitCurveDock::parametersChanged(bool updateParameterWidget) {
 	DEBUG("XYFitCurveDock::parametersChanged() m_initializing = " << m_initializing);
 
-	//parameter names were (probably) changed -> set the new names in EquationTextEdit
-	uiGeneralTab.teEquation->setVariables(m_fitData.paramNames);
+	//parameter names were (probably) changed -> set the new vars in ExpressionTextEdit teEquation
+	QStringList vars{m_fitData.paramNames};
+	vars << "x";	//TODO: generalize when we support other XYEquationCurve::EquationType
+	uiGeneralTab.teEquation->setVariables(vars);
 
 	if (m_initializing)
 		return;
